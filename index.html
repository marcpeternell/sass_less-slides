<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Frontend Advanced</title>

		<link rel="shortcut icon" type="image/png" href="./images/favicon.png">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Custom CSS -->
		<link rel="stylesheet" href="css/app.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img height="50%" width="50%" src="images/logo.png" alt="SAE Logo">
				</section>
				<!------------------- Titel ----------------------------->
				<section>
					<h1>CSS Präprozessoren</h1>
					<p>w/ Marc Peternell</p>
				</section>

				<!------------------- Agenda ----------------------------->
				<section>
					<h2>Was machen wir heute?</h2>
					<p>Vorstellrunde</p>
					<p>LESS</p>
					<p>SASS</p>
				</section>

				<!-- Wird noch auskommentiert -->
				<!------------------- Vorstellrunde ----------------------------->
				<section>
					<h2>Vorstellrunde</h2>
					<p>Name?</p>
					<p>Was habt ihr vor dem Studium gemacht?</p>
					<p>Arbeit? Wenn ja was?</p>
					<p>Wie seid ihr auf Webdevelopment gekommen?</p>
					<p>Hobbies?</p>
				</section>

				<!------------------- Warum Präprozessoren ----------------------------->
				<section>
					<h2>Warum Präprozessoren?</h2>
					<p>CSS Code ist ewig lang</p>
					<p>Organisation</p>
					<p>Änderungen</p>

					<aside class="notes" data-markdown>
						- Gehe zu https://www.instagram.com/ und zeige das CSS File aus dem Netzwerktab
						- Für jeden Context ein File z.B. ein File für alle Eigenschaften auf die Schrift bezogen
						- Bei Farben müssen bei jeder Änderungen sämtliche Stellen herausgesucht werden und geändert werden. Mit dem Präprozessoren können Variablen definiert werden welche anschließend im File referenziert werden
					</aside>
				</section>

				<!------------------- Gründe ----------------------------->
				<section>
					<h2>Beispiele</h2>
					<p>Schrift</p>
					<p>Präfixe</p>
					<p>Farbverläufe</p>
					<p>Modularität</p>
					<p>Wartung</p>

					<aside class="notes" data-markdown>
						- Anstatt jedes mal das gleiche zu schreiben für die Schrift, lieber einmal eine Variable definieren und diese nutzen.
						- (box-sizing muss mit webkit und für Firefox definiert werden) aus 3 Zeilen code wird eine. bzw generel 
						- Complexe Farbverläufe müssen nicht jedesmal wiederholt werden
						- Verschiedene Module und am Ende alles zusammenfassen
						- schneller, leichter und besser
						- Große Frameworks wie Boostrap verwenden auch Präprozessoren. 
					</aside>
				</section>

				<!------------------- Grundprinzip von Präprozessoren ----------------------------->
				<section>
					<h2>Grundprinzip</h2>
					<p>CSS Dateien</p>
					<p>LESS / SCSS Dateien</p>
					<p>Compiler</p>


					<aside class="notes" data-markdown>
						- Bis jetzt wurde immer direkt im CSS File eine Änderung gemacht und anschließend im Browser betrachtet
						- Bei Präprozessoren werden die CSS Dateien nicht mehr bearbeitet sondern die LESS / CSS Dateien. 
						- Die SASS / LESS Dateien werden mit einem Compiler compiliert
						- Wieder mehr Zeit für Spaßige CSS Sachen
					</aside>
				</section>

				<!------------------- Was ist ein Compiler ----------------------------->
				<section>
					<h2>Compiler</h2>
					<blockquote>
						Programm, das dazu dient, eine andere Programmiersprache in die Programmiersprache eines bestimmten Computers zu übersetzen
					</blockquote>

					<aside class="notes" data-markdown>
						- [sass](https://www.sassmeister.com/)
							- $color: red;
							@mixin transition {
							transition: background-color 2s ease-out;
							}
							p, a {
							@include transition;
							}
							p:hover {
							background-color: $color;
							}

						- [less](http://lesscssismore.com/)
							- @color: red;
							@padding: 10px;
							@border: 10px solid blue;
							@font: Helvetica, Arial, sans-serif;
							@important-color: orange;
							@second-color: blue;
							body {
							color: @color;
							font-family: @font;
							padding: @padding;
							border: @border;
							}
							footer {
							color : @second-color;
							background-color: @color;
							}

					</aside>
				</section>

				<!------------------- LESS vs SASS ----------------------------->
				<section>
					<h2>LESS / SASS</h2>
					<p>CSS Dateien schneller und besser erstellen</p>
				</section>

				<!------------------- Was sind die Unterschide ----------------------------->
				<section>
					<h2>Unterschied</h2>
					<p>Grundfunktionalität ist gleich</p>
					<p>Syntaktische Unterschiede</p>
				</section>

				<!------------------- SASS Syntax ----------------------------->
				<section>
					<h2>SASS</h2>
					<p>Variablen mit $</p>
					<p>Mixins mit @</p>
					<p>@include</p>
				</section>

				<!------------------- Warum SASS? ----------------------------->
				<section>
					<h2>Wieso SASS?</h2>
					<p>Foundation Framework</p>
					<p>compas</p>
					<aside class="notes" data-markdown>
						- [foundation](https://get.foundation/)
						- compass setzt auf sass 
							- compass ist ein sass framework, gemacht um die arbeit noch einfacher und effizienter zu gestallten 
							- [link](http://compass-style.org/)
							- so etwas in der art gibt es nur für SASS
					</aside>
				</section>

				<!------------------- LESS Syntax ----------------------------->
				<section>
					<h2>LESS</h2>
					<p>Variablen mit @</p>
					<p>Mixins wie CSS Klassen</p>
				</section>
				
				<!------------------- Wieso LESS ----------------------------->
				<section>
					<h2>Wieso LESS?</h2>
					<p>Boostrap Framework</p>
					<aside class="notes" data-markdown>
						- [Boostrap](https://getbootstrap.com/)
						- muss nicht vorher compiliert werden, kann durch eine js Datei beim aufrud der seite comiliert werden
					</aside>
				</section>

				<!------------------- Wieso LESS ----------------------------->
				<section>
					<h2>Was soll ich verwenden?</h2>
					<aside class="notes" data-markdown>
						- Es kommt auf das Umfled an. Wenn in der Arbeitsumgebung verschiedene Präprozessoren eingesetzt werden kommt es zu Fehlern. Bei Team arbeiten von Beginn an einigen um Fehler vorzubeugen.
					</aside>
				</section>



				<!------------------------------------------------------>
				<!------------------- LESS ----------------------------->
				<!------------------------------------------------------>
				<section>
					<h2>LESS</h2>
				</section>

				<!------------------- Clientseities Compilieren ----------------------------->
				<section>
					<h3>Clientseitig</h3>
					<pre class="html"><code>
&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;
&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/3.9.0/less.min.js&quot; &gt;&lt;/script&gt;
				   	</code></pre>

					<aside class="notes" data-markdown>
						- LESS kann auch direkt im Browser durch einbinden eines JS Compilers verwendet werden. 
							- wichtig ist hierbei das bei rel /less hinzugefügt werden muss
						- Beispiel 0 mit ihnen gemeinsam machen!
							- Wie man siehgt die less datei wird inline eingebunden
					</aside>
				</section>


				<!------------------- LESS über CLI ----------------------------->
				<section>
					<h3>CLI</h3>
					<p>Dateien zuerst compilieren und anschließend an den Browser übergeben</p>
					<aside class="notes">
						Das ist die weitaus elegantere Lösung. Bevor die daten an den browser gegeben werden, werden alle less dateien compiliert und in einer css datei zusammengefügt
					</aside>
				</section>
				<section >
					<section data-markdown>
						<textarea data-template>
							## Install
							```zsh
								npm install -g less
							```
							Mit **lessc** werden die Dateien compiliert
							```zsh
								lessc input.less output.css
							```

							Note: - es muss nodejs installiert sein 
							- es muss node installiert sein (node -v)
							- es muss npm installiert sein (npm -v)
							- wenn die Compilierung über CLI funktioniert, muss eine less Datei vorhanden sein. die CSS datei wird automatisch erstellt.
						</textarea>
					</section>
					<section>
						<h3><a href="https://nodejs.org/en/download/">Install nodejs</a></h3>
					</section>

				</section>

				<!------------------- Uebung 1 less Datei in eine CSS datei umwandeln mit CLI ----------------------------->
				<section>
					<h3><a href="./uebungen/Beispiel_1_cli.zip" download="">Übung 1</a></h3>
				</section>

				<!------------------- GUI Compiler ----------------------------->
				<section>
					<h3>GUI</h3>
					<p><a target="_blank" href="http://lesscss.org/tools/#guis-for-less">GUI List</a></p>

					<aside class="notes" data-markdown>
						- Wenn jemand nicht gerne mit der cl arbeitet gibt es natürlich auch guis 
						- Ein Vorteil von GUI Compiliern ist, dass sie die finalen CSS Dateien Minify'n. Das heisst der Whitespace wird entfernt um die Deigröße zu verkleinern.
					</aside>
				</section>

				<!------------------- Dont Repeat yourself ----------------------------->
				<section>
					<h3>Don't repeat yourself (dry)</h3>
					<pre class="css"><code data-line-numbers="2, 9, 14, 18">body {
	color: #fff;
	font-family: Helvetice, Arial, sans-serif;
	background-color: #7d9153;
}
							
footer {
	color: #7d9153;
	background-color: #fff;
}
							
nav {
	background-color: #d37130;
	border-left: 30px solid #fff;
}
							
nav a:link, nav a:visited{
	color: #fff;
}						
					</code></pre>
					<aside class="notes" data-markdown>
						- DRY gilt nicht nur für CSS. Egal ob man PHP, JS, C++, etc. programmiert. Sobald ein Ablauf mehr als einmal vorkommt sollte man mit Variabeln / Funktionen arbeiten.
						- Farben sind ein wunderschönes Beispiel für Wiederholungen.
						- Variablen helfen hier aus. 
							- Ich muss nur den Wert der Variable ändern und beim Compilieren wird die Variablen anschließend eingesetzt werden. 
					</aside>
				</section>

				<!------------------- Intro to Variablen ----------------------------->
				<section>
					<h3>Variablen</h3>
					<pre class="less"><code data-line-numbers="">@color: #000;
@width: 10px; // Werte
@border: 10px solid purple; // Complexere Ausdrücke
@bool: true; // Wird interessant wenn mit Bedingungen gearbeitet wird
@font: Helvetic, Arial, sans-serif; // Listen
					</code></pre>

					<aside class="notes" data-markdown>
						- Variablen können verschiedenste Werte übergeben bekommen.
					</aside>
				</section>

				<!------------------- Variablen zuweisen ----------------------------->
				<section>
					<h3>Zuweisung</h3>
						<pre class="less"><code data-line-numbers="">@font: Helvetic, Arial, sans-serif;
	
body{
	font-family: @font	
}
						</code></pre>	
						<aside class="notes" data-markdown>
							- Variablen werden gleich zugewiesen wie normale CSS Werte.
							- Mit einem @ Zeichen wird die Variable zugewiesen.
						</aside>				
				</section>

				<!------------------- Übung 2 Variablen einsetzen ----------------------------->
				<section>
					<h3><a href="./uebungen/Beispiel_2_variablen.zip" download>Übung 2</a></h3>
				</section>


				<!------------------- CSS Selectoren ----------------------------->
				<section>
					<h3>CSS Selectoren</h3>
						<pre class="css"><code data-line-numbers="">nav {
	ackground-color: #d37130;
	border-left: 30px solid #fff;
}

nav ul {
	list-style-type: none;
}

nav a:link, nav a:visited{
	color: @color;
}

nav a:hover,
nav a:active,
nav a:focus{
	background-color: orange;
}
						</code></pre>
						<aside class="notes" data-markdown>
							- in CSS werden Selectoren so geschrieben. 
							- was fällt euch auf ? 
							- mit LESS gibt es eine wunderbare Funktion die sich Nesting nennt.
						</aside>				
				</section>

				<!------------------- Nesting ----------------------------->
				<section>
					<h3>Nesting</h3>
						<pre class="less"><code data-line-numbers>nav {
	background-color: #d37130;
	border-left: 30px solid #fff;

	ul {
		list-style-type: none;
	}   

	a:link, nav a:visited{
		color: @color;
	}

	a:hover,
	a:active,
	a:focus{
		background-color: orange;
	}
}
						</code></pre>
						<aside class="notes" data-markdown="">
							- um nicht 50 mal nav zu schreiben, werden sämtliche andere elemente in der {} geschrieben
							- der Root selector kann nun sehr einfach geändert werden.
							- Der CSS Code verändert sich nicht. Es müssen wesentlich weniger Selectoren geschrieben werden. 
						</aside>				
				</section>

				<!------------------- Übung 3 ----------------------------->
				<section>
					<h3><a href="./uebungen/Beispiel_3_nesting.zip" download>Übung 3</a></h3>
				</section>

				<!------------------- Even more Nesting ----------------------------->
				<section>
					<h3>More Nesting</h3>
						<pre class="less"><code data-line-numbers="">nav {
    background-color: #d37130;
    border-left: 30px solid #fff;
  
    ul {
        list-style-type: none;
    }   
  
    a {
      &:link, 
      &:visited
      {
        color: @color;
      }
  
      &:hover,
      &:active,
      &:focus
      {
         background-color: orange;
      }
    }
}
						</code></pre>
						<aside class="notes" data-markdown>
							- Durch den & Selector kann können wir auch pseudo Klassen ansprechen
						</aside>				
				</section>

				<!------------------- Übung 4 ----------------------------->
				<section>
					<h3><a href="./uebungen/Beispiel_3_nesting.zip" download="">Übung 4</a></h3>
					<p>Dateien von Übung 3</p>
					<p>Verschachtelt die Selectoren mit dem & Selector weiter</p>
				</section>

				<!------------------- Warum das & Zeichen ----------------------------->
				<section>
					<h3>Warum "&" ?</h3>
						<pre class="less"><code data-line-numbers="">nav {
	...

	.post & {
		color: red
	}
}
						</code></pre>	

					<aside class="notes" data-markdown>
						- Beim Compilieren wird automatisch ein Leerzeichen für den nachfolgenden Selector erzeugt. Durch das & Zeichen wird dieses Leerzeichen nicht eingesetzt.
						- Wenn per Javascript zB. eine Klasse dem Eltern element hinzugefügt wird greift dieser selector
					</aside>
				</section>

				<!------------------- Mixins ----------------------------->
				<section>
					<h3>Mixins</h3>
					<p>Wiederverwendung</p>
					<aside class="notes" data-markdown>
						- Mixins ermöglichen die Wiederverwenung von Code Zeilen welche aus mehr als nur einer Zeile Code besteht.
						- Für Einfach Fälle werden Variablen genommen, welche anunterschiedlichen Stellen eingesetzt werden könne. Mixins schauen in Less genau so aus wie CSS Klassen. 
					</aside>
				</section>

				<!------------------- Anwendung von Mixins ----------------------------->
				<section>
					<h3>Anwendung</h3>
						<pre class="less"><code data-line-numbers="">@font: Helvetica;

.fontmedium {
	fontsize: 14px; // ältere Browser welche rem nicht verstehen, verwenden die 14px
	fontsize: 0.84rem; //rem ist eine relativ neue Schreibweise welche keine Probleme mit der Verärbung hat, es wird immer das Root-Element genommen
}

.transition {
	-webkit-transition: background-color 2s ease-out;
	-moz-transition: background-color 2s ease-out;
	-o-transition: background-color 2s ease-out;
	transition: background-color 2s ease-out;
}

body {
	color: red;
	font-family: @font;
	.fontmedium;
}

nav {
	a {
		.transition;
	}
}

						</code></pre>
						<aside class="notes" data-markdown>
							- Es ist das gleiche Prinzip wie bei Variablen DRY es hilef tauch bei der Code Wartung
							- Wenn Änderungen vorgenommen werden müssen, muss es nur an einer Stelle gemacht werden und nicht an 10 Stellen.
						</aside>					
				</section>

				<!------------------- Übung zu Mixings ----------------------------->
				<section>
					<h3><a href="./uebungen/Beispiel_5_mixins.zip" download>Übung 5</a></h3>
				</section>

				<!------------------- Mixins mit Parametern ----------------------------->
				<section>
					<h3>Mixins mit Parameter</h3>
						<pre class="less"><code data-line-numbers="">.uebergang_angepasst(@dauer: 1s, @eigenschaft: all, @art: ease) 
{
	-webkit-transition: @dauer @eigenschaft @art;
	transition: @dauer @eigenschaft @art;
}
  
body {
	.uebergang_angepasst(2s, background-color, linear);
}
						</code></pre>
					<aside class="notes" data-markdown>
						- eine weitere coole funktion von mixins sind parameter
						- Ähnlich wie bei JS kann auch bei LESS mit Parametern gearbeitet werden. 
						- Mixins ohne Parameter werden in die CSS Datei übernommen, weil sie sich von normalen CSS Klassen nicht unterscheiden. Durch das einfügen von () am ende der Mixins ohne Parameter werden diese nicht in das finale CSS file Übertragen.
					</aside>
				</section>

				<!------------------- Operatoren 1/2 ----------------------------->
				<section>
					<h3>Operatoren</h3>
					<pre class="less"><code data-line-numbers="">@base: 5%;
@filler: @base * 2;
@other: @base + @filler;
@base-color: #333;

body {
	color: #888 / 4;
	background-color: @base-color + #111;
	height: 100% / 2 + @filler;
}
					</code></pre>	
					<aside class="notes" data-markdown>
						- auch wenn das ganze nicht viel sinn ergibt
						- In Less kann man gewohnt wie in anderen Programmiersprachen Rechenoperationen durch führen
						- das sind die Theoretischen Möglichkeiten, doch wird man mit Farben im real Fall wenig Rechnen.
					</aside>
				</section>

				<!------------------- Operatoren 2/2 ----------------------------->
				<section>
					<h3>Operatoren</h3>
					<pre class="less"><code data-line-numbers="">@spalten: 12p;
@breite: 70px;
@abstand: 10px;
@element-breite: @spalten * (@breite + @abstand) + @ababstandstand;

main {
	width: @element-breite;
}
					</code></pre>
					<aside class="notes" data-markdown>
						- Eine etwas nützlichere Operation
						- Die Berechnung der Breite eines Elemens anhand der Spalten und der Breiten. 
					</aside>	
				</section>

				<!------------------- Importieren von Dateien ----------------------------->
				<section>
					<h3>Import</h3>
					<pre class="less"><code data-line-numbers="">@import 'font'; // Kein seperates Dokument wird im Browser eingebunden

@import 'font.css' // Ein CSS File wird mit einem Request vom server geladen
					</code></pre>	
					<aside class="notes" data-markdown>
						- Bei größeren Projekten will man CSS code auf mehrere Dateien aufteilen.
						- in Zeile 1 wird der reine Code einer LESS Datei importiert 
						- in Zeile 3 wird eine gesammtes CSS File beim Laden der Webseite importiert, das hat zur Folge das eine Seperater Request an den Server geht und die Performance darunter leidet. 
					</aside>	
				</section>

				<!------------------- Übung zu Imports ----------------------------->
				<section>
					<h3><a href="./uebungen/Beispiel_6_imports.zip" download>Übung 6</a></h3>
				</section>

				<section>
					<h3><a href="http://lesscss.org/functions/" target="_blank">LESS</a></h3>

				</section>
				
				<!------------------------------------------------------>
				<!------------------- Pause ----------------------------->
				<!------------------------------------------------------>

				<section>
					<h3>10 min Pause</h3>
				</section>


				<!------------------------------------------------------>
				<!------------------- SASS ----------------------------->
				<!------------------------------------------------------>
				<section>
					<h2>SASS</h2>
				</section>

				<!------------------- Install SASS ----------------------------->
				<section data-markdown>
					<textarea data-template>
						## Install
						```zsh
							npm install -g sass
						```
						Mit **sass** werden die Dateien compiliert
						```zsh
							sass --watch input.scss output.css
						```

						Note: - Wie bei LESS muss für SASS nodejs installiert sein.
						- Einvorteil von SASS ist, das SASS die watch funktion out of the Box anbietet. So muss nicht jedes mal die CLI betätigt werden sondern SASS überwacht ob etwas geändert wird.  
					</textarea>
				</section>

				<section>
					<h3><a href="./uebungen/Beispiel_1_cli.zip" download="">Übung 7</a></h3>
				</section>

				<!------------------- Die Verwendung von GUI's ----------------------------->
				<section>
					<h3>GUI</h3>
					<p><a href="https://scout-app.io/" target="_blank">Scout</a></p>
					<p><a href="http://koala-app.com/" target="_blank">Koala</a></p>
					<p><a href="https://www.sassmeister.com/" target="_blank">Sassmeister</a></p>
					<aside class="notes" data-markdown>
						- Wie bei LESS gibt es mehrere Möglichkeiten den geschriebenen Code zu Compilieren. 
						- Wieder würde ich euch nicht empfehlen GUI's zu verwenden.
					</aside>
				</section>

				<!------------------- Variablen definieren ----------------------------->
				<section>
					<h3>Variablen</h3>
					<pre class="sass "><code data-line-numbers="">$font-stack: Helvetica, sans-serif;
$primary-color: #333;
					</code></pre>	
					<aside class="notes" data-markdown>
						- im gegensatz zu LESS werden Variablen in SASS mit einem $ Zeichen definiert. 
						- Auch hier gilt wieder, das Variablen Werte, Listen etc. zugewiesen werden können. Speziell für komplexere Ausdrücke eignen sich Variablen herforragend.
					</aside>						
				</section>

				<!------------------- Variablen Zuweisen ----------------------------->
				<section>
					<h3>Zuweisung</h3>
					<pre class="sass "><code data-line-numbers="">body {
	font: $font-stack;
	color: $primary-color;
}
					</code></pre>		
					<aside class="notes" data-markdown>
						- die Variablen werden den Selectoren anschließend einfach zugeweisen. 
					</aside>
				</section>

				<section>
					<h3><a href="./uebungen/Beispiel_2_variablen.zip" download="">Übung 8</a></h3>
				</section>

				<!------------------- Schreibweisen ----------------------------->
				<section>
					<h3>Schreibweisen</h3>
					<p>SCSS</p>
					<p>Indented Syntax (SASS)</p>
					<aside class="notes" data-markdown>
						- Es gibt in SASS zwei verschiedene Schreibweisen. 
						- SCSS: ähnelt sehr der CSS schreibweise, es werden die {} verwendet.
						- SASS: ist die ältere Schreibweise und verwendet für die Zuweisungen Einrückungen. 
						- sass ist die alte schreibweise, scss ist die neue schreibweise
							- ein Vorgehen nach dem Vorbild von YAML
					</aside>
				</section>

				<!------------------- SCSS Schreibweise ----------------------------->
				<section>
					<h4>SCSS</h4>
					<pre class="sass "><code data-line-numbers="">body {
  color: $color;
  padding: 10px;
  font-family: Helvetica;
}
					</code></pre>
					<aside class="notes" data-markdown>
						- wie ihr seht sieht die scss schreibweise der CSS schreibweise sehr ähnlich, wenn die Variable nicht angegeben wäre, könnte nicht gesagt werden ob es scss oder css ist.
					</aside>				
				</section>

				<!------------------- SASS Schreibweise ----------------------------->
				<section>
					<h4>Indented Syntax</h4>
					<pre class="sass "><code data-line-numbers="">body
  color: red
  padding: 10px
  font-family: Helvetica
					</code></pre>
					<aside class="notes" data-markdown>
						- der Indented Syntax verwendet keine {}
						- es ist wichtig auf die Einrückungen der einzelenen selektoren zu achten. 
					</aside>				
				</section>

				<!------------------- Nesting ----------------------------->
				<section>
					<h3>Nesting</h3>
					<pre class="sass "><code data-line-numbers="">nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li {
	display: inline-block; 
	a {
        	display: block;
    		padding: 6px 12px;
    		text-decoration: none;
      }
  }
}
					</code></pre>
					<aside class="notes" data-markdown>
						- Wie LESS bietet auch SASS die Möglichkeit des Nestings
					</aside>
				</section>

				<section>
					<h3><a href="./uebungen/Beispiel_3_nesting.zip" download="">Übung 9</a></h3>
				</section>

				<!------------------- Mixins ----------------------------->
				<section>
					<h3>Mixins</h3>
					<pre class="sass "><code data-line-numbers="">@mixin border {
	padding: 20px;
	border: 1px solid green
}

@mixin transition {
	-webkit-transition: background-color 2s ease-out;
	-moz-transition: background-color 2s ease-out;
	-o-transition: background-color 2s ease-out;
	transition: background-color 2s ease-out;
}
					</code></pre>	
					<aside class="notes" data-markdown>
						- In gegensatz zu LESS werden Mixins nicht wie CSS Klassen definiert, sonder mit dem Zusatz @mixin. 
					</aside>
				</section>

				<!------------------- Mixins ----------------------------->
				<section>
					<h3>Mixins</h3>
					<pre class="sass "><code data-line-numbers="">p {
	@include border;
}
					</code></pre>	
					<aside class="notes" data-markdown>
						- Um Mixins einzubinden wird der begriff @include * verwendet.
					</aside>
				</section>

				<section>
					<h3><a href="./uebungen/Beispiel_5_mixins.zip" download="">Übung 10</a></h3>
				</section>

				<!------------------- Mixins mit Parameter ----------------------------->
				<section>
					<h3>Mixins mit Parameter</h3>
					<pre class="sass "><code data-line-numbers="">@mixin transition($duration: 1s, $property: all, $function: ease) {
	-webkit-transition: $duration $property $function;
	-moz-transition: $duration $property $function;
	-o-transition: $duration $property $function;
	transition: $duration $property $function;
}

.box {
	@include transition(2s, all, ease)
}
					</code></pre>	
					<aside class="notes" data-markdown>
						- Auch in SASS können Mixins mit Parametern ausgestattet werden. 
					</aside>
				</section>

				<!------------------- Operatoren ----------------------------->
				<section>
					<h3>Operatoren</h3>
					<pre class="sass "><code data-line-numbers="">.container {
	width: 100%;
  }
  
article {
	float: left;
	width: 600px / 960px * 100%;
}

aside {
	float: right;
	width: 300px / 960px * 100%;
}
					</code></pre>		
					<aside class="notes" data-markdown>
						- Wir haben ein einfaches, Gitter auf Basis von 960 Pixel erstellt. Mit den Operatoren in Sass können wir Pixelwerte ohne größere Umrechnungen in Prozent umrechen. 
					</aside>	
				</section>

				<!------------------- Dateien Importieren ----------------------------->
				<section>
					<h3>Import</h3>
					<pre class="sass "><code data-line-numbers="">//Eine CSS Datei wird Eingebunden und somit ein Request an den Server gestellt
@import "style.css";
//Eine sass datei wird beim compilieren eingebunden und der Code welcher in dieser Datei steht in die app.css datei eingefügt
@import "style";
//Diese Zeile wird übersprungen.
//@import "style";
					</code></pre>	
					<aside class="notes" data-markdown>
						- Ausperformance Gründen sollten so wenige Dateien wie möglich verwendet werden. Je mehr Dateien in CSS eingebunden werden, desto schlechter ist die Performance der Webseite. 
					</aside>					
				</section>

				<section>
					<h3><a href="./uebungen/Beispiel_6_imports.zip" download="">Übung 11</a></h3>
				</section>

				<section>
					<h3>Extend</h3>
					<pre class="sass "><code data-line-numbers="">/* This CSS will print because %message-shared is extended. */
%message-shared {
	border: 1px solid #ccc;
	padding: 10px;
	color: #333;
}

// This CSS won't print because %equal-heights is never extended.
%equal-heights {
	display: flex;
	flex-wrap: wrap;
}

.message {
	@extend %message-shared;
}

.success {
	@extend %message-shared;
	border-color: green;
}

.error {
	@extend %message-shared;
	border-color: red;
}

.warning {
	@extend %message-shared;
	border-color: yellow;
}
					</code></pre>
					<aside class="notes">
						<ul>
							<li>Das ist eines der nützlichsten Merkmale von SASS. Mit @extend kann ein Code Block von Eigenschaften eines Selectores zu einem weiteren weitergeben. Dadruch bleibt der Code übersichtlich. Im folgenden Beispiel werden Melungen für Fehler, Warnungen und Erfolge erstellt.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Output</h3>
					<pre class="css"><code data-line-numbers="">/* This CSS will print because %message-shared is extended. */
.message, .success, .error, .warning {
	border: 1px solid #ccc;
	padding: 10px;
	color: #333;
}

.success {
	border-color: green;
}

.error {
	border-color: red;
}

.warning {
	border-color: yellow;
}
					</code></pre>
					<aside class="notes">
						<ul>
							<li>Der Code weist .message, .success, .error und .warning an, sich genau wie %message-shared zu verhalten. Das bedeutet, dass überall, wo %message-shared auftaucht, auch .message, .success, .error und .warning auftaucht. Die Magie geschieht im generierten CSS, wobei jede dieser Klassen die gleichen CSS-Eigenschaften erhält wie %message-shared.</li>
							<li>Hinweis: %equal-heights wird nicht generiert, da %equal-heights niemals erweitert wird.</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3><a href="https://sass-lang.com/guide">SASS</a></h3>
				</section>

				<section>
					<h2>Vergleich</h2>
					<table>
						<thead>
							<tr>
								<th>SASS</th>
								<th>LESS</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Basiert auf Ruby</td>
								<td>Basiert auf Javascript</td>
							</tr>
							<tr>
								<td>Schleifen & Fallunterscheidungen</td>
								<td>Mixins können Situations bedingt eingesetzt werden</td>
							</tr>
						</tbody>
					</table>

					<aside class="notes">
						<ul>
							<li>LESS gibt Nutzern die Möglichkeit, Mixins nur dann zu aktivieren, wenn spezifische Situationen eintreffen. Das ist ein hilfreiches Feature, allerdings ist damit die Verwendung von logischen Verknüpfungen bei LESS schon ausgeschöpft.</li>
							<li>SASS hingegen bietet Schleifen und Fallunterscheidungen, wie man sie auch von Programmiersprachen kennt.</li>
							<li>SASS ist sehr viel beliebter unter Webdesignern. Dies kann allerdings auch daran liegen, dass SASS ein wenig älter ist. LESS hatte zunächst noch Unterstützung durch das geschätzte Frontend-Framework Bootstrap, das auf den jüngeren Präprozessor setzte. Doch mit Version 4 hat das Projekt offiziell auf SASS gewechselt, was die Popularität der Syntactically Awesome Style Sheets noch erhöhen dürfte.</li>
						</ul>
					</aside>
				</section>

				<!------------------- Download Handout ----------------------------->
				<section>
					<h2><a href="./script.pdf" download>Download Script</a></h2>
				</section>

			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			Reveal.initialize({
				hash: true,
				slideNumber: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/highlight/highlight.js' , async: true},
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
